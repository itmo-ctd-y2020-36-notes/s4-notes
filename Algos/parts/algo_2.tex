\subsubsection{Парасочетание в недвудольном графе}

Так же понемногу будем искать дополняющие пути и достраивать наше паросочетание.

Как уже было доказано, $M$ --- max парсоч $\iff$ не.~~~~т дополняющих путей.

Как искать дополняющие пути? Может быть заюзать \texttt{dfs}?

\begin{lstlisting}[mathescape=true]
    dfs(v, state)
        ...
    for n
        if state:
            (u,v) $\in$ M
        else:
            (u,v) $\in$ M
        dfs(n, !state)
\end{lstlisting}


Но так нельзя!

На таком графе не сработает:

\begin{center}
    \includegraphics[scale=0.6]{img/parsoch_dfs_bad_usage}
\end{center}

Проблема в том, что в какую-то вершину мы можем прийти с неправильной четностью.

\textit{\textbf{Утверждение}}: если такого не случилось, то все будет ок.\\
Пусть есть стартовая вершина.
Назовем вершину сомнительной, если до нее есть четный и нечетный пути. \\
Если в графе нет сомнительных вершин, такой граф можно переделать в двудольный и легко в нем постить паросочетание.

\begin{center}
    \includegraphics[scale=0.6]{img/parsoch_dfs_even_and_odd_paths}
\end{center}

Что делать?
Давайте запустим такой dfs.
Может быть три случая:
\begin{enumerate}
    \item Нашли дополняющий путь;
    \item Не нашли дополняющий путь и нет сомнительных вершин $\implies$ паросочетание макисмальное;
    \item Нашли сомнительную вершину.
\end{enumerate}

Если случилось третье, будем веселиться.
При помощи того же dfs-а найдем соцветие (blossom).
Внутри соцветия цикл нечетной длинны.

\begin{center}
    \includegraphics[scale=0.7]{img/parsoch_blossom}
\end{center}

Алгоритм называется blossom cut.
Возьмем все вершины соцветия и заменим на большую вершину.
\begin{center}
    \includegraphics[scale=0.5]{img/parsoch_blossom_cut}
\end{center}

Утверждение: если в исходном графе $G$ был дополняющий путь, то и в полученном графе $G^\prime$.

\begin{proof}
    Докажем в две стороны

    ($\Leftarrow$) Либо дополняющий путь вообще не проходит через большую вершину соцветия, тогда вообще все просто, ничего точно не поломается.\\
    Если дополгяющий путь проходит через большую вершину соцветия, то выберем кусок цикла нужной четности и соееденим кусочки дополняющего пути.
    \begin{center}
        \includegraphics[scale=0.35]{img/parsoch_blossom_cut_proof_1}
    \end{center}

    ($\Rightarrow$) Все сложно.
    Могут быть всякие сложные пути и после сжатия не понятно, что с ними делать.
    Конструктивно доказать сложно.

    Докажем при помощи теоремы о дополняющем пути.
    От противного.
    \begin{enumerate}
        \item Возьмем граф $G$ вместе с соцветием и инвертируем ему стебель,
        получим граф $H$ с валидным парсочем.
        \item Возьмем граф $H$ вместе с соцветием и инвертируем ему стебель,
        получим граф $H^\prime$ с валидным парсочем.

        \item
        Если в $G$ есть дополняющий путь, то и в $G^\prime$ тоже есть дополняющий путь (очевидно, так как и то и другое паросочетание не максимального размера).

        Если в $H^\prime$ есть дополняющий путь, то и в $H$ тоже есть дополняющий путь (очевидно, так как и то и другое паросочетание не максимального размера).

        Если в $G^\prime$ есть дополняющий путь, то и в $H^\prime$ есть дополняющий путь (конструктивно).
        \begin{center}
            \includegraphics[scale=0.475]{img/parsoch_blossom_cut_proof_2}
        \end{center}
    \end{enumerate}
\end{proof}

\paragraph*{Алгоритм}

\begin{lstlisting}[mathescape=true]
    M = $\varnothing$
    while True:
        dfs
        if нашли доп путь:
            разжать соцветие
            M++
            continue
        if нет додоп пути, не соцветий:
            break
        if соцветие:
            сжать соцветие
\end{lstlisting}

Итого, время работы алгоритма~--- $\mathcal{O}(n^2 m)$.

Как реализовать побыстрее? \textit{Немного пострадать}.

Пооптимизируем $DFS$.
Прямо проходя в DFS--е можно сжимать вершины.
Для этого можно быстро мерджить списки ребер.

\begin{center}
    \includegraphics[scale=0.5]{img/parsoch_blossom_cut_fast_dfs}
\end{center}

В общем, если постараться, можно получить решение $\mathcal{O}(n m \alpha (m, n))$.
А вообще, пацаны умеет делать за $\mathcal{O}(m \sqrt{n})$.

\endinput