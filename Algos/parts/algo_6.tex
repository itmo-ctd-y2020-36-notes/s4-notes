\subsection{Задача о назначениях}

Есть работы и работники. Стоимость назначения работника $i$ на раблоту $j$~--- $c_{ij }$. Нужно найти такое назначение, чтобы суммарное количество потраченных денег было минимальным.

\[
i \to p(i)\quad \min\sum C_{i, p(i)}
.\]

Другая формулировка: построим матрицу. В неё запишем стоимости, какой работник за какую работу хочет денег.
Тогда задача: выбрать в каждом столбце и строке по одной ячейке и минимизировать их сумму.

\begin{note}
    Простое действие: изменить все стоимости у одного работника на константу\ldots

    $i: C_{i,j} + =\Delta \quad j = 1..n$
\end{note}

\begin{example}Матрица работников
    \begin{center}
        \label{tab:mat}
        \begin{tabular}{|c|c|c|c|}
            \hline
            5&8&6&4\\ \hline
            1&2&1&2\\ \hline
            3&2&8&5\\ \hline
            5&4&6&3\\ \hline
        \end{tabular}
    \end{center}
\end{example}

\begin{statement}
    С помощью таких преобразований можно нормализовать матрицу и получить в некоторых ячейках $0$.
\end{statement}

\begin{example}
    Преобразуем её, вычев из каждой строки минимум:
    \begin{center}
        Матрица работников получше

        \label{tab:matbet}
        \begin{tabular}{|c|c|c|c|}
        \hline
        1&4&2&0\\
        \hline
        0&1&0&1\\
        \hline
        1&0&6&3\\
        \hline
        2&1&3&0\\
        \hline
        \end{tabular}

        $c_{i.j} \geqslant 0$.
    \end{center}
    Если по
\end{example}

Посмотрим на граф нулей. Он двудольный, поэтому нашу задачу можно свести к поиску максимального паросочетания.


\begin{lstlisting}[mathescape=true]
    for v $\in$ L // $\mathcal{O}(n)$
        while True: // $\mathcal O(n)$
            if dfs(v): // $\mathcal O(n^2)$
                M++
                break
            else: // $\mathcal O(n^2)$
                $\Delta$ = $\min C_{uv}$: u $\in L^+$, v $\in R^-$
                $C_{uv}$ -= $\Delta$, u$\in L^+$
                $C_{uv}$ += $\Delta$, v $\in R^+$
\end{lstlisting}

Алгоритмическая сложность: $\mathcal O(n^4)$.

\begin{theorem}
\begin{enumerate}
    \item После наших дейстивй не появятся отрицательные элементы.

    \begin{tabular}{c|c|c|}
        & $+\Delta$: $R^{+}$ & $R^-$ \\ \hline
        $-\Delta$: $L^+$ & $0$ & $-\Delta$\\ \hline
        $L^-$ & $+\Delta$ & $0$\\ \hline
    \end{tabular}~~~ $\Delta = \min$.

    \item После нашей операции досижимых вершин стало не меньше и старые остались достижимы.
\end{enumerate}
\end{theorem}

Давайте ускорять. Что мы делаем долго? Давайте не запускать dfs из нуля каждый раз. Мы находим те же вершины каждый раз вместе с новыми.
Давайте хранить bfs и просто идти по новому ребру, когда оно появляется.

Операции, которые хочется:
\begin{enumerate}
    \item $add\_row(i, \Delta)\quad a[j] +=\Delta$
    \item $add\_col(i, \Delta)\quad b[j] +=\Delta$
    \item $get(ij)\quad c[ij] + a[j] + b[j]$
\end{enumerate}

Давайте дополнительно хранить потенциалы для столбцов и строкю Пусть $a$~--- массив потециалов для строк, а $b$ --- массив потеницалов для столбцов.

Недостижимые вершины становятся достижимыми, но никогда не наоборот. Как будет находить минимум?
Посчитаем минимум по нужным столбцам. Дальше будем считать минимум за $n$ как минимум по столбцам.
Если столбец уходит -- за $n$ пересчитается. Если строка добавляется, за $n$ Обновляем минимумы во всех столбцах

\begin{lstlisting}[mathescape=true]
    for v $\in$ L: // $\mathcal{O}(n)$
        v$\in L^+$, остальные $\in L^-$
        $R^-$ = R
        m[j] += c[v,j]
        while True: // $\mathcal O{n}$
            $\Delta$, (vu) = $\min_{j\in R^-}$(m[j]) // $\mathcal{O}(n)$
            a[i] -= $\Delta\quad i\in L^+$
            b[j] += $\Delta\quad j\in R^+$
            m[j] -= $\Delta$
            $R^+$ = $R^+$ U {u}
            if p[u] = $\varnothing$:
                инвертируем дополняющий путь // $\mathcal{O}(n)$
            else:
                $L^{+} = L^{+} \cup$ { p(n) }
                m[j] = min (m[j], c[p(n), j] + a[p[n]] + b[j])  // $\mathcal O(n)$
\end{lstlisting}

Итого, алгоритмическая сложность~--- $\mathcal O(n^3)$.

Давайте дальше ускорять. Для нахождение минимального ребра можно использовать двоичную кучу.
К этой куче нужно добавить операцию изменения весов всех элементов на константу.

Теперь $\mathcal O(nm\ln n)$.

Можно сделать фббоначиеву кучу. $\mathcal O(n\ln n + m)$



% перенос