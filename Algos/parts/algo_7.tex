\subsection{Задача о назначениях}

Есть работы и работники. Стоимость назначения работника $i$ на раблоту $j$~--- $c_{ij }$. Нужно найти такое назначение, чтобы суммарное количество потраченных денег было минимальным.

\[
i \to p(i)\quad \min\sum C_{i, p(i)}
.\]

Другая формулировка: построим матрицу. В неё запишем стоимости, какой работник за какую работу хочет денег.
Тогда задача: выбрать в каждом столбце и строке по одной ячейке и минимизировать их сумму.

\begin{note}
    Простое действие: изменить все стоимости у одного работника на константу\ldots

    $i: C_{i,j} + =\Delta \quad j = 1..n$
\end{note}

\begin{example}Матрица работников
    \begin{center}
        \label{tab:mat}
        \begin{tabular}{|c|c|c|c|}
            \hline
            5&8&6&4\\ \hline
            1&2&1&2\\ \hline
            3&2&8&5\\ \hline
            5&4&6&3\\ \hline
        \end{tabular}
    \end{center}
\end{example}

\begin{statement}
    С помощью таких преобразований можно нормализовать матрицу и получить в некоторых ячейках $0$.
\end{statement}

\begin{example}
    Преобразуем её, вычев из каждой строки минимум:
    \begin{center}
        Матрица работников получше

        \label{tab:matbet}
        \begin{tabular}{|c|c|c|c|}
        \hline
        1&4&2&0\\
        \hline
        0&1&0&1\\
        \hline
        1&0&6&3\\
        \hline
        2&1&3&0\\
        \hline
        \end{tabular}

        $c_{i.j} \geqslant 0$.
    \end{center}
    Если по
\end{example}

Посмотрим на граф нулей. Он двудольный, поэтому нашу задачу можно свести к поиску максимального паросочетания.


\begin{lstlisting}[mathescape=true]
    for v $\in$ L // $\mathcal{O}(n)$
        while True: // $\mathcal O(n)$
            if dfs(v): // $\mathcal O(n^2)$
                M++
                break
            else: // $\mathcal O(n^2)$
                $\Delta$ = $\min C_{uv}$: u $\in L^+$, v $\in R^-$
                $C_{uv}$ -= $\Delta$, u$\in L^+$
                $C_{uv}$ += $\Delta$, v $\in R^+$
\end{lstlisting}

Алгоритмическая сложность: $\mathcal O(n^4)$.

\begin{theorem}
\begin{enumerate}
    \item После наших дейстивй не появятся отрицательные элементы.

    \begin{tabular}{c|c|c|}
        & $+\Delta$: $R^{+}$ & $R^-$ \\ \hline
        $-\Delta$: $L^+$ & $0$ & $-\Delta$\\ \hline
        $L^-$ & $+\Delta$ & $0$\\ \hline
    \end{tabular}~~~ $\Delta = \min$.

    \item После нашей операции досижимых вершин стало не меньше и старые остались достижимы.
\end{enumerate}
\end{theorem}

Давайте ускорять. Что мы делаем долго? Давайте не запускать dfs из нуля каждый раз. Мы находим те же вершины каждый раз вместе с новыми.
Давайте хранить bfs и просто идти по новому ребру, когда оно появляется.

Операции, которые хочется:
\begin{enumerate}
    \item $add\_row(i, \Delta)\quad a[j] +=\Delta$
    \item $add\_col(i, \Delta)\quad b[j] +=\Delta$
    \item $get(ij)\quad c[ij] + a[j] + b[j]$
\end{enumerate}

Давайте дополнительно хранить потенциалы для столбцов и строкю Пусть $a$~--- массив потециалов для строк, а $b$ --- массив потеницалов для столбцов.

Недостижимые вершины становятся достижимыми, но никогда не наоборот. Как будет находить минимум?
Посчитаем минимум по нужным столбцам. Дальше будем считать минимум за $n$ как минимум по столбцам.
Если столбец уходит -- за $n$ пересчитается. Если строка добавляется, за $n$ Обновляем минимумы во всех столбцах

\begin{lstlisting}[mathescape=true]
    for v $\in$ L: // $\mathcal{O}(n)$
        v$\in L^+$, остальные $\in L^-$
        $R^-$ = R
        m[j] += c[v,j]
        while True: // $\mathcal O{n}$
            $\Delta$, (vu) = $\min_{j\in R^-}$(m[j]) // $\mathcal{O}(n)$
            a[i] -= $\Delta\quad i\in L^+$
            b[j] += $\Delta\quad j\in R^+$
            m[j] -= $\Delta$
            $R^+$ = $R^+$ U {u}
            if p[u] = $\varnothing$:
                инвертируем дополняющий путь // $\mathcal{O}(n)$
            else:
                $L^{+} = L^{+} \cup$ { p(n) }
                m[j] = min (m[j], c[p(n), j] + a[p[n]] + b[j])  // $\mathcal O(n)$
\end{lstlisting}

Итого, алгоритмическая сложность~--- $\mathcal O(n^3)$.

Давайте дальше ускорять. Для нахождение минимального ребра можно использовать двоичную кучу.
К этой куче нужно добавить операцию изменения весов всех элементов на константу.

Теперь $\mathcal O(nm\ln n)$.

Можно сделать фббоначиеву кучу. $\mathcal O(n\ln n + m)$



% перенос
\section{Поток минимальной стоимости}

%\begin{figure}[!ht]
%    \centering
%    \incfig{min-stream}
%    \caption{min-stream}
%    \label{fig:min-stream}
%\end{figure}

\begin{definition}
    Вес потока -- сумма стоимости по всем рёбрам

    \[
        W = \sum_{vu} f_{vu}\cdot w_{vu}
    .\] 
\end{definition}
\begin{problem}
    Найти минимальный по стомости максимальный поток
\end{problem}

Пусть сначала $w_{uv}\geqslant 0$.

Возьмём нулевой поток. $F_0 = 0, f_{uv} = 0$. Будем увеличивать поток на 1.

 $F_1 = 1$ -- путь минимального веса. 

 $F_{k+1}-F_k = \Delta F$  поток в остаточной сети $F_ k$ 

 $\Delta F$ -- путь  $\min \sum w$ в остаточной сети  $F_{k}$ 
 
 Алгоритм 1:
 \begin{lstlisting}
     while True:
        Ford-Bellman(s,t) // nm
        if нет пути:
            break
        else
            дополнительный поток вдоль кратчайшего пути
 \end{lstlisting}

 $\mathcal O\left( F \cdot nm \right) $

 У нас нет отрицательный циклов. Можем ввести потенциалы: $\varphi_v:\quad \p \omega_{uv} = \omega_{uv} + \varphi_u - \varphi_v \geqslant 0$ (неравенство треугольника, если взять расстояние)

 $\varphi_v = dist(s,v)$

 $\p \omega = \omega_{uv} +\varphi_u - \varphi_v = 0$

 $\varphi_v = dist(s,v) = \varphi_u + \omega_{uv}$

Алгоритм 2: заменить форда-беллмана на дейкстру

$\mathcal O\left( F \cdot  \left( m + n\log n \right)  \right) $ 

А что делать если есть торицательные рёбра, но всё ещё нет отрицательных циклов. Тогда самый первый подсчёт потенциалов заменится на Форда-Беллмана

$\mathcal O\left( F \cdot (m + n\log n) + mn \right) $ 

Кажется, что если разрешить отрицательные циклы, то всё будет плохо с минимальными путями. Но у нас потоки, у них есть пропускная способность и она ограничивает снизу стоимость.

$F = 0$ -- находим цикл с отрицательным весом и пихаем по нему единицу жижи, пока можем. Пока не сойдётся.

Другой подход -- протечь во всем отрицательным рёбрам максимум того, что течёт. Потом добить до правильного потока.

$O\left( m \cdot  C \cdot  (m + n\log n) \right) $ 

\subsection{Масштабирование}

$C_{uv} = 0$

Два действия:
 \begin{enumerate}
     \item $C_{uv} += 1$ одному ребру
     \item  $C_{uv} *= 2$ для всех рёбер
\end{enumerate}

\begin{statement}
    Такими действиями можно быстро добиться оригинальных $C_{uv}$
\end{statement}

$F$ -- текущая циркуляция

Inv:  $W_F$ -- минимальный возможный. В остаточной сети нет отрицательных циклов (иначе можно было бы пихнуть по ним жижу и уменьшить стоимость)

$F$ не минимальный,  $F_{\min}$

$\Delta F = F_{\min} - F < 0$

$\Delta F$ -- циркуляция в остаточной сети.  $W(\Delta F) <0 \ldots$

Есть в остаточной сети нет отрициательных циклов, то поток минимальный.

Рассмотрим действия:
\begin{enumerate}
    \item Умножение -- просто умножить количество жижи на 2
    \item Прибавление 1. Поищем расстояние между вершинами добавленного ребра. Если $dis(u,v) + \omega_{uv}>0$, то всё хорошо, просто добавляем и не паримся

        Если стало меньше 0, то появился отрицательный цикл, по которому можн пихнуть только одну еиницу жижи (т.к. мы добавили пропускную способность только 1)
\end{enumerate}         

$\mathcal O\left( m\log C\cdot mn \right) $, если Фордом-Беллманом.

$\mathcal O\left( m\log C \cdot \left( m + n\log n \right)  \right) $
