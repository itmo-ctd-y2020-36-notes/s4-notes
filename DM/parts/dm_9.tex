\section{Формальные языки}

Как объяснить комьютеру, что я вляется словом в нашем языке.

Пусть $L \subset L^{*}$.
Мы знаем два способа задания языка. \begin{enumerate}
    \item ДКА $=$ Р.В.
    \item КСГ $=$ МП-автомат.
\end{enumerate}

А что мы вообще сделать с помощью компьютера? Ну что-то нельзя сделать из-за фикики: путешествовать во времени, \ldots.
А что нельзя сделать с помощью математики?

Есть два способа рассказать компьютеру о языке: \begin{itemize}
    \item Научить его распознавать слово из языка.

    Например, ДКА. Нужен мета-язык описания конечных автоматов и само описание автомата.

    \item Научить компьютер пораждать слова из языка.

    У нас есть также мета-язык описания пораждения языка и само описание.

    Например, даем компьютеру парсер регулярных выражений, само регулярное выражение, компьютер строит дерево разбора и генерирует нам слова.
\end{itemize}

На сколько сильно мы можем усложнить граматику нашего языка.
Регулярные языки не умели геренрировать палиндромы, КСГ не умели генерировать $1^n 2^n 3^n$. А на сколько еще мы можем усложнить наши описания?

Вообще, языков может быть $2^{\Sigma ^{*}}$ --- несчетное количество. Но для нас это не страшно, почти все из них описать не возможно.
А что можно описать? Ну пусть то, что умеет понимать компьютер.
\textbf{ А что такое вообще компьютер? }

Для осознания мощности компьютеров существуют модели. Мы будем изучать \textbf{Машину Тьюринга}. Машина Тьюринга основывается на ленте. Так же существует, например, машина Маркова, там немного другой принцип.

\subsubsection*{Метод описания}

Пусть у нас есть \textit{соременный x86} компьютер. Как описать модель такого комьютера? Ну есть почти неограниченная память и есть какие-то операции (сложение, умножение, вызов функции).
Что такое программа для такого компьютера? Программа --- $\underbrace{\,\,\,\,\,\,\,\,\,\,\,\,}_{\text{строка}} \in \Pi^{*}$. На самом деле можно записать в битовом формате $\mathbb{B} = \{0, 1 \}$, то есть $\underbrace{\,\,\,\,\,\,\,\,\,\,\,\,}_{\text{Description}} \in \mathbb{B}^{*}$.
На самом деле, описание программ самый мощный инструмен. Пусть есть описание конченого автомата, запишим его в константу, добавим код имплементации конечного автомата, получим описание языка от автомата на языке программ.


\begin{statement}[Тезиси Тьюринга--Чёрча]
    Все, что можно выразить на <<обычном компьютере>> можно выразить на Машине Тьюринга.
\end{statement}

\begin{note}
    Почему это не утверждение или теорема? Надо доопределить понятие <<обычный комьютер>> и тогда получится какое-то утверждение.
\end{note}

А что вообще может выдавать программа? \textit{Comilation error} не больная проблема, давайте в таком случае программа будет делать что-то конкретное, например $No$.
Если \textit{Runtime error}, путь тоже будем возвращать что-то конкретное. \textit{Memory limit}~--- не проблема, попросим пользователя добавить память или подождем, пока изобретут комьютер лучше. Самое интересное~--- \textit{Time limit}, это обозначают $\perp$. Таким, образом наша программа будет возвращать три значения $\true, \false, \perp$. Тогда хочется добавить ограничение на время исполненя, правда, это немного ограничит класс зязыков.

\begin{definition}
    Язык $L$ разрешимый (рекурсивный), если $\exists $ программа $p$ $\forall x \in L \implies p(x) = 1, ~~~ x \not\in L \implies p(x) = 0$.
\end{definition}

\begin{definition}
    Язык $L$ полуразрешимый (перечислимый, рекурсивнно перечислимый), если $\exists $ программа $p$ $\forall x \in L \iff p(x) = 1$.
\end{definition}

На самом деле полуразрешимые описания языков --- мкисмальные по мощности.
Разрешимый --- максимальный по мощности прикладной способ описания.

Существуют не разрешимые и не полуразрешимые языки.

\subsubsection*{Метод порождения}

Пусть у нас есть компьютер, который по опсанию выводит список слов. Можно выводить первые $n$ слов.

Опять же, понятно, что описание с помощью компьютера макисмальное по мощности.

\begin{definition}
    Язык $L$ перечеслимым, если можно написать программу, которая выодит его слова.
\end{definition}

\begin{theorem}
    $L$ полуразрешим $\iff$ $L$ перечислим.
\end{theorem}

\begin{definition}
    Градуированный лексикографический порядк~--- перечисление  в порядке увеличения длинны, а среди слов с равной длинны лексикографически.
\end{definition}


\begin{proof}
    $\Longrightarrow$

    Неверный подход 1.
\begin{lstlisting}[mathescape=true]
    for (x $\in \Sigma^{*}$)
        if $p (x)$:
            print(x)
\end{lstlisting}

Не верный поход, попытка 2
\begin{lstlisting}[mathescape=true]
    for (TL = 1; True; TL++)
        for (x $\in$ \Sigma^{*})
            if p $|_{\mathrm{T}}$ (x):
                print(x)
\end{lstlisting}

Подход правильный:
\begin{lstlisting}[mathescape=true]
    for (TL = 1; True; TL++)
        for (x $\in \Sigma^{*}[:TL]$)
            if p $ |_{\mathrm{T}}$ (x):
                if (x $\not\in$ was):
                    print(x)
                    was.add(x)
\end{lstlisting}


$\Longleftarrow $

Пусть у нас есть $q$~--- перечислитель $L$.
\begin{lstlisting}[mathescape=true]
p(x):
    while q.next() != x:
        pass
    return True
\end{lstlisting}
\end{proof}

\subsubsection*{Пример непреичлимого языка}

Программа набор из $0$ и $1$.
Пусть $A$~--- предикат.
$L_A = \{ p \mid A(p) \}$~--- формальный язык.

\begin{definition}
    [Универсальный язык] $U = \{ \langle p, x \rangle \mid p(x) = 1\}$.
\end{definition}

\begin{note}
$U$~--- полуразрешим.
\end{note}
\begin{proof}
    Давайте сделаем
\begin{lstlisting}[mathescape=true]
inU($\langle p, x \rangle$):
    return p(x)
\end{lstlisting}
\end{proof}

\begin{theorem}
    $U$ не разрешим.
\end{theorem}
\begin{proof}
    Пусть есть функция inU($\langle p, x \rangle$)~--- всегда завершается.
\begin{lstlisting}[mathescape=true]
q(x):
    if inU($\langle x, x \rangle$):
        return 0
    else:
        return 1
\end{lstlisting}
Посчитаем q(q).

Если q(q) $= 1\implies $ inU($\langle q, q \rangle$) = false $\implies$ q(q) = 0 (плохо).

Пусть q(q) $= 0 \implies $ inU ($\langle q, q \rangle $) = true
$\implies$ q(q) = 1 (тоже плохо).

\end{proof}

\begin{theorem}
    Если $A$ и $\overline{A}$~--- полуразрешим $\implies A$~--- разрешим.
\end{theorem}

\begin{statement}
    $A$ разрешим $\implies $ $\overline{A}$~--- разрешим.
\end{statement}

\begin{proof}[Доказательство теоремы]
.
\begin{lstlisting}[mathescape=true]
inA(x):
    for (TL = 1; $+\infty$):
        if p $|_{TL}$(x):
            return 1
        if q $|_{TL}$(x):
            return 0
\end{lstlisting}
\end{proof}

\subsubsection*{Не полуразрешим}

\begin{example}
    Язык дополнение до $U$ не полуразрешим.
\end{example}

На самом деле эти множества биективны:
\begin{itemize}
    \item Строки $\Sigma^{*}$
    \item Программы Prog
    \item Числа $\N^+$
\end{itemize}
Prog $\underset{\mathrm{id}}{\iff} \Sigma^{*}$ $\underset{\mathrm{grad\, order}}{\iff} \N^+$.

\begin{itemize}
    \item Полуразрешимые языки $\iff$ вычислимые функции $A \subset \N \to \{0 , 1\}$.
    \item Разрешимые языки $\iff$ всюду определенные (Hall) вычислимые функции $\N \to \{0 , 1\}$.
\end{itemize}
